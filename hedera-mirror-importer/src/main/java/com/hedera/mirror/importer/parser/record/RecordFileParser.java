package com.hedera.mirror.importer.parser.record;

/*-
 * ‌
 * Hedera Mirror Node
 * ​
 * Copyright (C) 2019 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import com.google.common.base.Stopwatch;
import com.hederahashgraph.api.proto.java.Transaction;
import com.hederahashgraph.api.proto.java.TransactionBody.DataCase;
import com.hederahashgraph.api.proto.java.TransactionRecord;
import io.micrometer.core.instrument.DistributionSummary;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
import javax.inject.Named;
import lombok.extern.log4j.Log4j2;
import org.apache.commons.codec.binary.Hex;

import com.hedera.mirror.importer.domain.ApplicationStatusCode;
import com.hedera.mirror.importer.parser.FileWatcher;
import com.hedera.mirror.importer.parser.domain.StreamFileInfo;
import com.hedera.mirror.importer.repository.ApplicationStatusRepository;
import com.hedera.mirror.importer.util.FileDelimiter;
import com.hedera.mirror.importer.util.Utility;

/**
 * This is a utility file to read back service record file generated by Hedera node
 */
@Log4j2
@Named
public class RecordFileParser extends FileWatcher {

    private final ApplicationStatusRepository applicationStatusRepository;
    private final RecordParserProperties parserProperties;
    private final MeterRegistry meterRegistry;

    // Metrics
    private final Timer.Builder parseDurationMetric;
    private final Timer.Builder transactionLatencyMetric;
    private final DistributionSummary.Builder transactionSizeMetric;

    public RecordFileParser(ApplicationStatusRepository applicationStatusRepository,
                            RecordParserProperties parserProperties, MeterRegistry meterRegistry) {
        super(parserProperties);
        this.applicationStatusRepository = applicationStatusRepository;
        this.parserProperties = parserProperties;
        this.meterRegistry = meterRegistry;

        parseDurationMetric = Timer.builder("hedera.mirror.parse.duration")
                .description("The duration in ms it took to parse the file and store it in the database");

        transactionSizeMetric = DistributionSummary.builder("hedera.mirror.transaction.size")
                .description("The size of the transaction in bytes")
                .baseUnit("bytes");

        transactionLatencyMetric = Timer.builder("hedera.mirror.transaction.latency")
                .description("The difference in ms between the time consensus was achieved and the mirror node " +
                        "processed the transaction");
    }

    /**
     * Given a service record name, read its prevFileHash
     *
     * @param fileName the name of record file to read
     * @return return previous file hash's Hex String
     */
    public static String readPrevFileHash(String fileName) {
        File file = new File(fileName);
        if (file.exists() == false) {
            log.warn("File does not exist {}", fileName);
            return null;
        }
        byte[] prevFileHash = new byte[48];
        try (DataInputStream dis = new DataInputStream(new FileInputStream(file))) {
            // record_format_version
            dis.readInt();
            // version
            dis.readInt();

            byte typeDelimiter = dis.readByte();

            if (typeDelimiter == FileDelimiter.RECORD_TYPE_PREV_HASH) {
                dis.read(prevFileHash);
                String hexString = Hex.encodeHexString(prevFileHash);
                log.trace("Read previous file hash {} for file {}", hexString, fileName);
                return hexString;
            } else {
                log.error("Expecting previous file hash, but found file delimiter {} for file {}", typeDelimiter,
                        fileName);
            }
        } catch (Exception e) {
            log.error("Error reading previous file hash {}", fileName, e);
        }

        return null;
    }

    /**
     * @return return boolean indicating method success
     */
    private boolean loadRecordFile(String fileName, InputStream inputStream) {
        String previousFileHash = applicationStatusRepository
                .findByStatusCode(ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH);
        String thisFileHash = Hex.encodeHexString(Utility.getFileHash(fileName));
        StreamFileInfo streamFileInfo = new StreamFileInfo(fileName, thisFileHash, previousFileHash);

        long counter = 0;
        byte[] readFileHash = new byte[48];
        RecordFileLogger.INIT_RESULT initFileResult = RecordFileLogger.initFile(streamFileInfo);
        Stopwatch stopwatch = Stopwatch.createStarted();
        Integer recordFileVersion = 0;
        Boolean success = false;

        if (initFileResult == RecordFileLogger.INIT_RESULT.OK) {
            try (DataInputStream dis = new DataInputStream(inputStream)) {
                recordFileVersion = dis.readInt();
                int version = dis.readInt();

                log.info("Loading version {} record file: {}", recordFileVersion, fileName);

                while (dis.available() != 0) {

                    try {
                        byte typeDelimiter = dis.readByte();

                        switch (typeDelimiter) {
                            case FileDelimiter.RECORD_TYPE_PREV_HASH:
                                dis.read(readFileHash);

                                if (Utility.hashIsEmpty(previousFileHash)) {
                                    log.error("Previous file hash not available");
                                    previousFileHash = Hex.encodeHexString(readFileHash);
                                }

                                String newFileHash = Hex.encodeHexString(readFileHash);

                                log.trace("New file hash = {}, old hash = {}", newFileHash, previousFileHash);

                                if (!newFileHash.contentEquals(previousFileHash)) {

                                    if (applicationStatusRepository
                                            .findByStatusCode(ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER)
                                            .compareTo(Utility.getFileName(fileName)) < 0) {
                                        // last file for which mismatch is allowed is in the past
                                        log.error("Hash mismatch for file {}. Previous = {}, Current = {}", fileName,
                                                previousFileHash, newFileHash);
                                        RecordFileLogger.rollback();
                                        return false;
                                    }
                                }
                                break;
                            case FileDelimiter.RECORD_TYPE_RECORD:
                                counter++;

                                int byteLength = dis.readInt();
                                byte[] rawBytes = new byte[byteLength];
                                dis.readFully(rawBytes);
                                Transaction transaction = Transaction.parseFrom(rawBytes);

                                byteLength = dis.readInt();
                                rawBytes = new byte[byteLength];
                                dis.readFully(rawBytes);
                                TransactionRecord txRecord = TransactionRecord.parseFrom(rawBytes);

                                try {
                                    if (log.isTraceEnabled()) {
                                        log.trace("Transaction = {}, Record = {}", Utility
                                                .printProtoMessage(transaction), Utility.printProtoMessage(txRecord));
                                    } else {
                                        log.debug("Storing transaction with consensus timestamp {}", () -> Utility
                                                .printProtoMessage(txRecord.getConsensusTimestamp()));
                                    }

                                    RecordFileLogger.storeRecord(transaction, txRecord, rawBytes);
                                } finally {
                                    // TODO: Refactor to not parse TransactionBody twice
                                    DataCase dc = Utility.getTransactionBody(transaction).getDataCase();
                                    String type = dc != null && dc != DataCase.DATA_NOT_SET ? dc.name() : "UNKNOWN";
                                    transactionSizeMetric.tag("type", type)
                                            .register(meterRegistry)
                                            .record(rawBytes.length);

                                    Instant consensusTimestamp = Utility
                                            .convertToInstant(txRecord.getConsensusTimestamp());
                                    transactionLatencyMetric.tag("type", type)
                                            .register(meterRegistry)
                                            .record(Duration.between(consensusTimestamp, Instant.now()));
                                }
                                break;
                            case FileDelimiter.RECORD_TYPE_SIGNATURE:
                                int sigLength = dis.readInt();
                                byte[] sigBytes = new byte[sigLength];
                                dis.readFully(sigBytes);
                                log.trace("File {} has signature {}", fileName, Hex.encodeHexString(sigBytes));
                                break;

                            default:
                                log.error("Unknown record file delimiter {} for file {}", typeDelimiter, fileName);
                                RecordFileLogger.rollback();
                                return false;
                        }
                    } catch (Exception e) {
                        log.error("Exception {}", e);
                        RecordFileLogger.rollback();
                        return false;
                    }
                }

                log.trace("Calculated file hash for the current file {}", thisFileHash);
                RecordFileLogger.completeFile(streamFileInfo);

                if (!Utility.hashIsEmpty(thisFileHash)) {
                    applicationStatusRepository
                            .updateStatusValue(ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH, thisFileHash);
                }

                success = true;
            } catch (Exception e) {
                log.error("Error parsing record file {} after {}", fileName, stopwatch, e);
                RecordFileLogger.rollback();
            } finally {
                log.info("Finished parsing {} transactions from record file {} in {}", counter, fileName, stopwatch);

                parseDurationMetric.tag("type", "record")
                        .tag("success", success.toString())
                        .tag("version", recordFileVersion.toString())
                        .register(meterRegistry)
                        .record(stopwatch.elapsed());
            }

            return success;
        } else if (initFileResult == RecordFileLogger.INIT_RESULT.SKIP) {
            return true;
        } else {
            RecordFileLogger.rollback();
            return false;
        }
    }

    // TODO: Test for file sorted
    @Override
    public void onCreate() {
        listAndProcessAllFiles(this::loadRecordFile);
    }

    @Override
    public boolean isDataFile(String filename) {
        return Utility.isRecordFile(filename);
    }
}
